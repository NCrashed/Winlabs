[$name|Lexer$]
[$title|class Lexer$]
[$frame|HTMLPage.tmpl$]

<ul>
<li>
	[$typeLink|Lexer| class Lexer $]
	<ul>
	<li>[$typeLink|Lexer_{languageName}| class Lexer_{languageName}$][$ident| : Lexer $]</li>
	</ul>
</li>
</ul>

[$apiSectionType| Lexer | goldie.lexer | class Lexer $]
<div class="api-def">
	[$apiHead|[: readonly @property Token[] tokens :]$]
	<div class="api-def">
		The tokens that resulted from the last lexing.
	</div>
	[$apiHead|[: readonly @property LexError[] errors :]$]
	<div class="api-def">
		The lexical errors encountered during the last lexing.
	</div>

	[$apiHead|[: string source :]$]
	<div class="api-def">
		The original source that was last lexed.
	</div>

	[$apiHead|[: ptrdiff_t[] lineIndicies :]$]
	<div class="api-def">
	<p>
		Indicies into [$ident|source$] where each line starts. For example,
		[$code|inline|[:lineIndicies[0]:]$] is the index where the first line
		starts (always 0), [$code|inline|[:lineIndicies[1]:]$] is the index
		where the second line starts, etc.
	</p>
	<p>
		See the example in [$ident|lineAtIndex$] below.
	</p>
	</div>

	[$apiHead|[: ptrdiff_t lineAtIndex(ptrdiff_t index) :]$]
	<div class="api-def">
	<p>
		Returns the line number (zero-indexed) of a given index into the
		source that was lexed. As per Goldie
		[$pageLink|APIOver#LineColumn|conventions$], this value
		should be increased by one whenever it's displayed to the user.
	</p>
	<p>
		Example:
	</p>
		[$code|highlight|
[:string src =
"ABC
DEF
HIJ";

auto lexerUsed = someLanguage.lexCodeX(src);

auto numLines = lexerUsed.lineIndicies.length;

// Get everything from start of second line, to start of third line
auto secondLine = src[ lexerUsed.lineIndicies[1] .. lexerUsed.lineIndicies[2] ]

writeln("Number of lines: ", numLines);
writeln("Second line: ", secondLine);
writefln("src[9] is '%s' and is on line #%s",
	src[9], 1 + lexerUsed.lineAtIndex(9));

// Output:
// Number of lines: 3
// Second line: DEF
// 
// src[9] is 'I' and is on line #3
:]$]
	</div>

	[$apiHead|[: string filename :]$]
	<div class="api-def">
	<p>
		The filename (if available) of the last source lexed.
	</p>
	</div>

	[$apiHead|[: 
	ptrdiff_t srcIndex
	ptrdiff_t line
	:]$]
	<div class="api-def">
	<p>
		Internal lexer state. Access is provided to these for diagnostic
		purposes.
		If an exception is thrown during lexing, then these can be inspected
		to check the lexer's internal state at the time of the exception.
		This is probably only useful for debugging Goldie.
	</p>
	</div>

	[$apiHead|[: Token[] process(string source, Language lang, string filename="") :]$]
	<div class="api-def">
	<p>
		Lexes (ie, tokenizes) a source. Throws a [$typeName|LexException$] if
		the source contains an error.
	</p>
	<p>
		Normally, you would use one of the
		[$typeName|Language$][$ident|.parse$] or [$typeName|Language$][$ident|.lex$]
		functions instead of calling this directly,
		but this direct access is provided in case you'd rather re-use the
		same lexer instead of instantiating a new one every time.
	</p>
	<p>
		The filename from which the source originated can be provided
		so error messages can report the appropriate filename.
	</p>
	</div>
</div>

[$apiSectionType| Lexer_{languageName} | {user-specified package}.lexer | class Lexer_{languageName} : Lexer $]
<div class="api-def">
	<div class="api-head">
		{languageName} = Name of static-style language
	</div>
	<p>
	This is the [$pageLink|StatVsDyn|static-style$] counterpart to
	[$pageName|Lexer$], and is generated by the
	[$pageName|StaticLang$] tool.
	</p>
	<p>
	If the name of a language is, for example, [$ident|foo$], then
	the name of this class will be [$ident|Lexer_foo$].
	</p>
	<p>
	The interface is the same as [$typeName|Lexer$].
	</p>
</div>
