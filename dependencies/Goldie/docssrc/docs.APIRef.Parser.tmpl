[$name|Parser$]
[$title|class Parser$]
[$frame|HTMLPage.tmpl$]

<ul>
<li>
	[$typeLink|Parser| class Parser $]
	<ul>
	<li>[$typeLink|Parser_{languageName}| class Parser_{languageName}$][$ident| : Parser $]</li>
	</ul>
</li>
</ul>

[$apiSectionType| Parser | goldie.parser | class Parser $]
<div class="api-def">
	
	[$apiHead|[: Token parseTreeX :]$]
	<div class="api-def">
		The root token in the parse tree of the last source parsed.
	</div>
	
	[$apiHead|[: Lexer lexer :]$]
	<div class="api-def">
		The Lexer that was used to lex the source before parsing.
	</div>
	
	[$apiHead|[: Language lang :]$]
	<div class="api-def">
		The Language that was used to lex and parse the source.
	</div>
	
	[$apiHead|[: string filename :]$]
	<div class="api-def">
		The filename (if available) of the last source parsed.
	</div>
	
	[$apiHead|[: 
	int[] rulesUsed
	Stack!Token tokenStack
	Stack!int stateStack
	Token currTok
	int tokIndex
	int state
	:]$]
	<div class="api-def">
	<p>
		Internal parser state. Access is provided to these for diagnostic
		purposes.
		If an exception is thrown during parsing, then these can be inspected
		to check the parser's internal state at the time of the exception.
		This is probably only useful for debugging Goldie.
	</p>
	<p>
		The templated type
		[$ident| Stack!T $]
		is defined in the module
		[$link| https://bitbucket.org/Abscissa/semitwistdtools/src/goldie-v0.9/src/semitwist/util/container.d | semitwist.util.container $]
		from
		[$pageLink| Requires#SemiTwist | SemiTwist D Tools $].
	</p>
	</div>

	[$apiHead|[: Token process(Token[] tokens, Language lang, string filename="", Lexer lexer=null) :]$]
	<div class="api-def">
	<p>
		Parses a series of tokens. Throws a [$typeName|ParseException$]
		if the source contains an error.
	</p>
	<p>
		Normally, you would use one of the
		[$typeName|Language$][$ident|.parse$] functions instead of calling this directly,
		but this direct access is provided in case you'd rather re-use the
		same parser instead of instantiating a new one every time.
	</p>
	<p>
		The filename from which the source originated can be provided
		so error messages can report the appropriate filename.
	</p>
	<p>
		The [$typeName|Lexer$] that was used to lex the source can be provided
		so that, upon any error, the [$typeName|ParseException$] can provide
		access to all the lexing information.
	</p>
	<p>
		Returns [$ident|parseTreeX$].
	</p>
	</div>
</div>

[$apiSectionType| Parser_{languageName} | {user-specified package}.parser | class Parser_{languageName} : Parser $]
<div class="api-def">
	<div class="api-head">
		{languageName} = Name of static-style language
	</div>
	<p>
	This is the [$pageLink|StatVsDyn|static-style$] counterpart to
	[$pageName|Parser$], and is generated by the
	[$pageName|StaticLang$] tool.
	</p>
	<p>
	If the name of a language is, for example, [$ident|foo$], then
	the name of this class will be [$ident|Parser_foo$].
	</p>
	
	<a name="Parser_parseTree" />
	<div class="api-head">
		[$typeName|Token_{languageName}!{symbol}$] [$ident|parseTree$]
	</div>
	<div class="api-def">
	<p>
		Type-safe [$pageLink|StatVsDyn|static-style$] counterpart to
		[$typeName|Parser$][$ident|.parseTreeX$].
	</p>
	<p>
		Since the actual rule used for the root can only be known
		at runtime (because it depends on the actual source parsed), this is a
		[$typeName|Token_{languageName}!{symbol}$] and not
		a [$typeName|Token_{languageName}!{rule}$]. So in order to access
		the subtokens, you will need to determine which rule was used,
		like this:
	</p>
[$code|highlight|
[:// Assume the language "calc":
// "Start Symbol" = <Add Exp>
// <Add Exp> ::= <Add Exp> '+' <Mult Exp>
//             | <Add Exp> '-' <Mult Exp>
//             | <Mult Exp>
void foo(string src)
{
	Parser_calc parserUsed = language_calc.parseCode(src);
	
	Token_calc!"<Add Exp>" rootUnknownRule = parserUsed.parseTree;
	
	// This is the static-style equivilent to using Token.matches()
	if( auto root =
		cast(Token_calc!("<Add Exp>", "<Mult Exp>"))rootUnknownRule )
	{
		// Use root
	}
	else if( auto root =
		cast(Token_calc!("<Add Exp>", "<Add Exp>", "+", "<Mult Exp>"))rootUnknownRule )
	{
		// Use root
	}
	else if( auto root =
		cast(Token_calc!("<Add Exp>", "<Add Exp>", "-", "<Mult Exp>"))rootUnknownRule )
	{
		// Use root
	}
	else
		throw new Exception("Forgot to handle some other rule!");
}
:]$]		
	</div>
</div>
